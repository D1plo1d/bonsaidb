<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BonsaiDb User&#x27;s Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">About BonsaiDb</li><li class="chapter-item expanded "><a href="about/concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/concepts/document.html"><strong aria-hidden="true">1.1.</strong> Document</a></li><li class="chapter-item expanded "><a href="about/concepts/collection.html"><strong aria-hidden="true">1.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="about/concepts/view.html"><strong aria-hidden="true">1.3.</strong> View</a></li><li class="chapter-item expanded "><a href="about/concepts/schema.html"><strong aria-hidden="true">1.4.</strong> Schema</a></li><li class="chapter-item expanded "><a href="about/concepts/database.html"><strong aria-hidden="true">1.5.</strong> Database</a></li><li class="chapter-item expanded "><a href="about/concepts/storage.html"><strong aria-hidden="true">1.6.</strong> Storage</a></li><li class="chapter-item expanded "><a href="about/concepts/pubsub.html"><strong aria-hidden="true">1.7.</strong> PubSub</a></li></ol></li><li class="chapter-item expanded "><a href="about/access_models.html"><strong aria-hidden="true">2.</strong> How can BonsaiDb be accessed?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/access-models/custom-api-server.html"><strong aria-hidden="true">2.1.</strong> Custom Api Server</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Integration</li><li class="chapter-item expanded "><a href="integration/overview.html"><strong aria-hidden="true">3.</strong> Overview</a></li><li class="chapter-item expanded "><a href="integration/async.html"><strong aria-hidden="true">4.</strong> Async vs Blocking</a></li><li class="chapter-item expanded "><a href="integration/local.html"><strong aria-hidden="true">5.</strong> Local</a></li><li class="chapter-item expanded "><a href="integration/server.html"><strong aria-hidden="true">6.</strong> Networked</a></li><li class="chapter-item expanded "><a href="integration/cluster.html"><strong aria-hidden="true">7.</strong> Clustered (upcoming)</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Traits</li><li class="chapter-item expanded "><a href="traits/connection.html"><strong aria-hidden="true">8.</strong> Connection</a></li><li class="chapter-item expanded "><a href="traits/storage_connection.html"><strong aria-hidden="true">9.</strong> StorageConnection</a></li><li class="chapter-item expanded "><a href="traits/pubsub.html"><strong aria-hidden="true">10.</strong> PubSub</a></li><li class="chapter-item expanded "><a href="traits/key-value.html"><strong aria-hidden="true">11.</strong> KeyValue</a></li><li class="chapter-item expanded "><a href="traits/key.html"><strong aria-hidden="true">12.</strong> Key</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="traits/key/enum.html"><strong aria-hidden="true">12.1.</strong> Using an Enum as a Key</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="administration/configuration.html"><strong aria-hidden="true">13.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="administration/permissions.html"><strong aria-hidden="true">14.</strong> Permissions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="administration/permission-statements.html"><strong aria-hidden="true">14.1.</strong> Permission Statements</a></li><li class="chapter-item expanded "><a href="administration/rbac.html"><strong aria-hidden="true">14.2.</strong> Users, Groups, and Roles</a></li></ol></li><li class="chapter-item expanded "><a href="administration/encryption.html"><strong aria-hidden="true">15.</strong> At-Rest Encryption</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BonsaiDb User&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bonsaidb-users-guide"><a class="header" href="#bonsaidb-users-guide">BonsaiDb User's Guide</a></h1>
<p>BonsaiDb is an ACID-compliant, document-database written in Rust. Its goal is to be a general-purpose database that aims to simplify development and deployment by providing reliable building blocks that are lightweight enough for hobby projects running with minimal resources, but scalable for when your hobby project becomes a deployed product.</p>
<p>This user's guide aims to provide a guided walkthrough for users to understand how BonsaiDb works. This guide is meant to be supplemental <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/">to the documentation</a>. If you learn best by exploring examples, <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples">many are available in <code>/examples</code> in the repository</a>. If, however, you learn best by taking a guided tour of how something works, this guide is specifically for you.</p>
<p>If you have any feedback on this guide, please <a href="https://github.com/khonsulabs/bonsaidb/issues">file an issue</a>, and we will try to address any issues or shortcomings.</p>
<p>Thank you for exploring BonsaiDb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>This is a list of common concepts that will be used throughout this book as well as the documentation.</p>
<ul>
<li><a href="about/./concepts/document.html">Document</a></li>
<li><a href="about/./concepts/collection.html">Collection</a></li>
<li><a href="about/./concepts/view.html">View</a></li>
<li><a href="about/./concepts/schema.html">Schema</a></li>
<li><a href="about/./concepts/database.html">Database</a></li>
<li><a href="about/./concepts/storage.html">Storage</a></li>
<li><a href="about/./concepts/pubsub.html">PubSub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document"><a class="header" href="#document">Document</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/trait.Document.html">Document</a> is a single piece of stored data. Each document is stored within a <a href="about/concepts/./collection.html"><code>Collection</code></a>, and has a unique ID within that Collection. There are two document types: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.OwnedDocument.html"><code>OwnedDocument</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.BorrowedDocument.html"><code>BorrowedDocument</code></a>. The <a href="about/concepts/./view.html#map"><code>View::map()</code> function</a> takes a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.BorrowedDocument.html"><code>BorrowedDocument</code></a>, but nearly every other API utilizes <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.OwnedDocument.html"><code>OwnedDocument</code></a>.</p>
<p>When a document is updated, BonsaiDb will check that the revision information passed matches the currently stored information. If not, a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/enum.Error.html#variant.DocumentConflict">conflict error</a> will be returned. This simple check ensures that if two writers try to update the document simultaneously, one will succeed and the other will receive an error.</p>
<h2 id="serializable-collections"><a class="header" href="#serializable-collections">Serializable Collections</a></h2>
<p>BonsaiDb provides the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a> trait, which allows automatic serialization and deserialization in many sitautions. When using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html#method.document_contents"><code>SerializedCollection::document_contents()</code></a> function, the document is serialized and deserialized by the format returned from <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html#tymethod.format"><code>SerializedCollection::format()</code></a>.</p>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.CollectionDocument.html"><code>CollectionDocument&lt;T&gt;</code></a> type provides convenience methods of interacting with serializable documents.</p>
<h3 id="default-serialization-of-serde-compatible-types"><a class="header" href="#default-serialization-of-serde-compatible-types">Default serialization of Serde-compatible types</a></h3>
<p>BonsaiDb provides a convenience trait for <a href="https://serde.rs/">Serde</a>-compatible data types: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.DefaultSerialization.html"><code>DefaultSerialization</code></a>. This empty trait can be implemented on any collection to have BonsaiDb provide its preferred serialization format, <a href="https://github.com/khonsulabs/pot">Pot</a>.</p>
<h2 id="raw-collections"><a class="header" href="#raw-collections">Raw Collections</a></h2>
<p>If you would prefer to manually manage the data stored inside of a Document, you can directly manage the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.OwnedDocument.html#structfield.contents"><code>contents</code></a> field. BonsaiDb will not interact with the <code>contents</code> of a Document. Only code that you write will parse or update the stored data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection"><a class="header" href="#collection">Collection</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.Collection.html">Collection</a> is
a group of <a href="about/concepts/./document.html">Documents</a> and associated functionality. Collections
are stored on-disk using ACID-compliant, transactional storage, ensuring your
data is protected in the event of a sudden power failure or other unfortunate
event.</p>
<p>The goal of a Collection is to encapsulate the logic for a set of data in
such a way that Collections could be designed to be shared and reused in
multiple <a href="about/concepts/./schema.html">Schemas</a> or applications.</p>
<p>Each Collection must have a unique
<a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/struct.CollectionName.html"><code>CollectionName</code></a>.
To help prevent naming collisions, an <code>authority</code> can be specified which
provides a level of namespacing.</p>
<p>A Collection can contain one or more <a href="about/concepts/./view.html">Views</a>.</p>
<h2 id="primary-keys"><a class="header" href="#primary-keys">Primary Keys</a></h2>
<p>All documents stored in a collection have a unique id. Primary keys in BonsaiDb
are immutable -- once a document has an id, it cannot be changed. If you wish
for a unique key that can be updated, use a unique view, and use a separate
value as a primary key.</p>
<p>The type is controlled by the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.Collection.html#associatedtype.PrimaryKey"><code>Collection::PrimaryKey</code> associated
type</a>. If you're using the derive macro, the type can be specified
using the <code>primary_key</code> parameter as in <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/primary-keys.rs">this example</a>:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Debug, Serialize, Deserialize, Collection, Eq, PartialEq)]
#[collection(name = &quot;multi-key&quot;, primary_key = AssociatedProfileKey)]
struct AssociatedProfileData {
    value: String,
}

#[derive(Key, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
struct AssociatedProfileKey {
    pub user_id: u32,
    pub data_id: u64,
}
</code></pre>
<p>If no <code>primary_key</code> is specified in the derive, <code>u64</code> will be used.</p>
<p>Inserting and accessing the collection can be done using the newly defined
primary key type:</p>
<pre><code class="language-rust noplayground no_run">    let key = AssociatedProfileKey {
        user_id: user.header.id,
        data_id: 64,
    };
    let inserted = AssociatedProfileData {
        value: String::from(&quot;hello&quot;),
    }
    .insert_into(&amp;key, &amp;db)?;
    let retrieved = AssociatedProfileData::get(&amp;key, &amp;db)?.expect(&quot;document not found&quot;);
    assert_eq!(inserted, retrieved);
</code></pre>
<h3 id="natural-ids"><a class="header" href="#natural-ids">Natural Ids</a></h3>
<p>It's not uncommon to need to store data in a database that has an &quot;external&quot;
identifier. Some examples could be externally authenticated user profiles,
social networking site posts, or for normalizing a single type's fields across
multiple Collections. These types of values are often called &quot;Natural Keys&quot; or
&quot;Natural Identifiers&quot;.</p>
<p><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html#method.natural_id"><code>SerializedCollection::natural_id()</code></a> or
<a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.DefaultSerialization.html#method.natural_id"><code>DefaultSerialzation::natural_id</code></a> can be implemented to return
a value from the contents of a new document. When using the derive marco, the
<code>natural_id</code> parameter can be specified with either a closure or a path to a
function with the same signature.</p>
<p>In this <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/primary-keys.rs">example</a>, the <code>UserProfile</code> type is used to represent a user that has a
unique ID in an external database:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Debug, Serialize, Deserialize, Collection, Eq, PartialEq)]
#[collection(name = &quot;user-profiles&quot;, primary_key = u32, natural_id = |user: &amp;UserProfile| Some(user.external_id))]
struct UserProfile {
    pub external_id: u32,
    pub name: String,
}
</code></pre>
<p>When pushing a <code>UserProfile</code> into the collection, the id will automatically be
assigned by calling <code>natural_id()</code>:</p>
<pre><code class="language-rust noplayground no_run">    let user = UserProfile {
        external_id: 42,
        name: String::from(&quot;ecton&quot;),
    }
    .push_into(&amp;db)?;
    let retrieved_from_database = UserProfile::get(&amp;42, &amp;db)?.expect(&quot;document not found&quot;);
    assert_eq!(user, retrieved_from_database);
</code></pre>
<h3 id="custom-primary-keys"><a class="header" href="#custom-primary-keys">Custom Primary Keys</a></h3>
<p>All primary keys must implement the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html"><code>Key</code> trait</a> . BonsaiDb provides implementations for many types, but any type that implements the trait can be used.</p>
<p>When using <code>push</code>/<code>push_into</code>, BonsaiDb needs to assign a unique ID to the incoming document. If <code>natural_id()</code> returns None, the storage backend will handle id assignment.</p>
<p>If the document being pushed is the first document in the collection, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html#method.first_value"><code>Key::first_value()</code></a> is called and the resulting value is used as the document's id.</p>
<p>If the collection already has documents, the highest-ordered key is queried from
the collection. <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html#method.next_value"><code>Key::next_value()</code></a> is then called and the resulting value is
used as the document's id. <code>Key</code> implementors should not allow <code>next_value()</code> to
return a value that is less than the current value. <code>NextValueError::WouldWrap</code>
should be returned instead of wrapping.</p>
<p>Both <code>first_value()</code> and <code>next_value()</code> by default return
<code>NextValueError::Unimplemented</code>. If any error occurs while trying to assign a
unique id, the transaction will be aborted and rolled back.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.View.html">View</a> is a <a href="https://en.wikipedia.org/wiki/MapReduce">map/reduce</a>-powered method of quickly accessing information inside of a <a href="about/concepts/./collection.html">Collection</a>. Each View can only belong to one Collection.</p>
<p>Views define two important associated types: a <a href="about/concepts/../../traits/key.html">Key</a> type and a Value type. You can think of these as the equivalent entries in a map/dictionary-like collection that supports more than one entry for each Key. The Key is used to filter the View's results, and the Value is used by your application or the <code>reduce()</code> function.</p>
<p>Views are a powerful, yet abstract concept. Let's look at a concrete example: blog posts with categories.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Serialize, Deserialize, Debug, Collection)]
#[collection(name = &quot;blog-post&quot;, views = [BlogPostsByCategory])]
pub struct BlogPost {
    pub title: String,
    pub body: String,
    pub category: Option&lt;String&gt;,
}
</code></pre>
<p>Let's insert this data for these examples:</p>
<pre><code class="language-rust no_run noplayground">    BlogPost {
        title: String::from(&quot;New version of BonsaiDb released&quot;),
        body: String::from(&quot;...&quot;),
        category: Some(String::from(&quot;Rust&quot;)),
    }
    .push_into(&amp;db)?;

    BlogPost {
        title: String::from(&quot;New Rust version released&quot;),
        body: String::from(&quot;...&quot;),
        category: Some(String::from(&quot;Rust&quot;)),
    }
    .push_into(&amp;db)?;

    BlogPost {
        title: String::from(&quot;Check out this great cinnamon roll recipe&quot;),
        body: String::from(&quot;...&quot;),
        category: Some(String::from(&quot;Cooking&quot;)),
    }
    .push_into(&amp;db)?;
</code></pre>
<blockquote>
<p>All examples on this page are available in their full form in the repository at <a href="https://github.com/khonsulabs/bonsaidb/tree/main/book/book-examples/tests">book/book-examples/tests</a>.</p>
</blockquote>
<p>While <code>category</code> should be an enum, let's first explore using <code>String</code> and upgrade to an enum at the end (it requires one additional step). Let's implement a View that will allow users to find blog posts by their category as well as count the number of posts in each category.</p>
<pre><code class="language-rust noplayground no_run">#[derive(Debug, Clone, View)]
#[view(collection = BlogPost, key = Option&lt;String&gt;, value = u32, name = &quot;by-category&quot;)]
pub struct BlogPostsByCategory;

impl ViewSchema for BlogPostsByCategory {
    type View = Self;

    fn map(&amp;self, document: &amp;BorrowedDocument&lt;'_&gt;) -&gt; ViewMapResult&lt;Self::View&gt; {
        let post = BlogPost::document_contents(document)?;
        document.header.emit_key_and_value(post.category, 1)
    }

    fn reduce(
        &amp;self,
        mappings: &amp;[ViewMappedValue&lt;Self::View&gt;],
        _rereduce: bool,
    ) -&gt; ReduceResult&lt;Self::View&gt; {
        Ok(mappings.iter().map(|mapping| mapping.value).sum())
    }
}
</code></pre>
<p>The two traits being implemented are <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.View.html">View</a> and
<a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.ViewSchema.html">ViewSchema</a>. These traits are designed to allow keeping the
<code>View</code> implementation in a shared code library that is used by both client-side
and server-side code, while keeping the <code>ViewSchema</code> implementation in the
server executable only.</p>
<h2 id="views-for-serializedcollection"><a class="header" href="#views-for-serializedcollection">Views for <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a></a></h2>
<p>For users who are using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a>, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.CollectionViewSchema.html"><code>CollectionViewSchema</code></a> can be implemented instead of <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.ViewSchema.html"><code>ViewSchema</code></a>. The only difference between the two is that the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.CollectionViewSchema.html#tymethod.map"><code>map()</code></a> function takes a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/struct.CollectionDocument.html"><code>CollectionDocument</code></a> instead of a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/document/trait.Document.html"><code>BorrowedDocument</code></a>.</p>
<h2 id="value-serialization"><a class="header" href="#value-serialization">Value Serialization</a></h2>
<p>For views to function, the Value type must able to be serialized and deserialized from storage. To accomplish this, all views must implement the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedView.html"><code>SerializedView</code></a> trait. For <a href="https://serde.rs/">Serde</a>-compatible data structures, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.DefaultViewSerialization.html"><code>DefaultSerializedView</code></a> is an empty trait that can be implemented instead to provide the default serialization that BonsaiDb recommends.</p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>The first line of the <code>map</code> function calls <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html#method.document_contents"><code>SerializedCollection::document_contents()</code></a> to deserialize the stored <code>BlogPost</code>. The second line returns an emitted Key and Value -- in our case a clone of the post's category and the value <code>1_u32</code>. With the map function, we're able to use <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/struct.View.html#method.query"><code>query()</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/struct.View.html#method.query_with_docs"><code>query_with_docs()</code></a>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_posts = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(&amp;Some(String::from(&quot;Rust&quot;)))
        .query_with_docs()?;
    for mapping in &amp;rust_posts {
        let post = BlogPost::document_contents(mapping.document)?;
        println!(
            &quot;Retrieved post #{} \&quot;{}\&quot;&quot;,
            mapping.document.header.id, post.title
        );
    }
</code></pre>
<p>The above snippet queries the <a href="about/concepts/./database.html">Database</a> for all documents in the <code>BlogPost</code> Collection that emitted a <a href="about/concepts/../../traits/key.html">Key</a> of <code>Some(&quot;Rust&quot;)</code>.</p>
<p>If you're using a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a>, you can use <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/struct.View.html#method.query_with_collection_docs"><code>query_with_collection_docs()</code></a> to have the deserialization done automatically for you:</p>
<pre><code class="language-rust noplayground no_run">    let rust_posts = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(&amp;Some(String::from(&quot;Rust&quot;)))
        .query_with_collection_docs()?;
    for mapping in &amp;rust_posts {
        println!(
            &quot;Retrieved post #{} \&quot;{}\&quot;&quot;,
            mapping.document.header.id, mapping.document.contents.title
        );
    }
</code></pre>
<h2 id="reduce"><a class="header" href="#reduce">Reduce</a></h2>
<p>The second function to learn about is the <code>reduce()</code> function. It is responsible for turning an array of Key/Value pairs into a single Value. In some cases, BonsaiDb might need to call <code>reduce()</code> with values that have already been reduced one time. If this is the case, <code>rereduce</code> is set to true.</p>
<p>In this example, we're using the built-in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>Iterator::sum()</code></a> function to turn our Value of <code>1_u32</code> into a single <code>u32</code> representing the total number of documents.</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(&amp;Some(String::from(&quot;Rust&quot;)))
        .reduce()?;
    assert_eq!(rust_post_count, 2);
</code></pre>
<h2 id="changing-an-exising-view"><a class="header" href="#changing-an-exising-view">Changing an exising view</a></h2>
<p>If you have data stored in a view, but want to update the view to store data
differently, implement <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.ViewSchema.html#method.version"><code>ViewSchema::version()</code></a> and return
a unique number. When BonsaiDb checks the view's integrity, it will notice that
there is a version mis-match and automatically re-index the view.</p>
<p>There is no mechanism to access the data until this operation is complete.</p>
<h3 id="understanding-re-reduce"><a class="header" href="#understanding-re-reduce">Understanding Re-reduce</a></h3>
<p>Let's examine this data set:</p>
<div class="table-wrapper"><table><thead><tr><th>Document ID</th><th>BlogPost Category</th></tr></thead><tbody>
<tr><td>1</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>2</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>3</td><td>Some(&quot;Cooking&quot;)</td></tr>
<tr><td>4</td><td>None</td></tr>
</tbody></table>
</div>
<p>When updating views, each view entry is reduced and the value is cached. These
are the view entries:</p>
<div class="table-wrapper"><table><thead><tr><th>View Entry ID</th><th>Reduced Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
</div>
<p>When a reduce query is issued for a single key, the value can be returned without further processing. But, if the reduce query matches multiple keys, the View's <code>reduce()</code> function will be called with the already reduced values with <code>rereduce</code> set to <code>true</code>. For example, retrieving the total count of blog posts:</p>
<pre><code class="language-rust noplayground no_run">    let total_post_count = db.view::&lt;BlogPostsByCategory&gt;().reduce()?;
    assert_eq!(total_post_count, 3);
</code></pre>
<p>Once BonsaiDb has gathered each of the key's reduced values, it needs to further reduce that list into a single value. To accomplish this, the View's <code>reduce()</code> function to be invoked with <code>rereduce</code> set to <code>true</code>, and with mappings containing:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
</div>
<p>This produces a final value of 4.</p>
<h2 id="how-does-bonsaidb-make-this-efficient"><a class="header" href="#how-does-bonsaidb-make-this-efficient">How does BonsaiDb make this efficient?</a></h2>
<p>When saving Documents, BonsaiDb does not immediately update related views. It instead notes what documents have been updated since the last time the View was indexed.</p>
<p>When a View is accessed, the queries include an <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/enum.AccessPolicy.html"><code>AccessPolicy</code></a>. If you aren't overriding it, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/enum.AccessPolicy.html#variant.UpdateBefore"><code>UpdateBefore</code></a> is used. This means that when the query is evaluated, BonsaiDb will first check if the index is out of date due to any updated data. If it is, it will update the View before evaluating the query.</p>
<p>If you're wanting to get results quickly and are willing to accept data that might not be updated, the access policies <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/enum.AccessPolicy.html#variant.UpdateAfter"><code>UpdateAfter</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/enum.AccessPolicy.html#variant.NoUpdate"><code>NoUpdate</code></a> can be used depending on your needs.</p>
<p>If multiple simulataneous queries are being evaluted for the same View and the View is outdated, BonsaiDb ensures that only a single view indexer will execute while both queries wait for it to complete.</p>
<h2 id="using-arbitrary-types-as-a-view-key"><a class="header" href="#using-arbitrary-types-as-a-view-key">Using arbitrary types as a View Key</a></h2>
<p>In our previous example, we used <code>String</code> for the Key type. The reason is important: Keys must be sortable by <a href="https://github.com/khonsulabs/nebari">our underlying storage engine</a>, which means special care must be taken. Most serialization types do not guarantee binary sort order. Instead, BonsaiDb exposes the <a href="about/concepts/../../traits/key.html"><code>Key</code> trait</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.Schema.html">Schema</a> is a group of one or more <a href="about/concepts/./collection.html">Collections</a>. A Schema can be instantiated as a <a href="about/concepts/./database.html">Database</a>. The Schema describes how a set of data behaves, and a Database is a set of data on-disk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>A Database is a set of stored data. Each Database is described by a <a href="about/concepts/./schema.html">Schema</a>. Unlike the other concepts, this concept corresponds to multiple types:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>All of these types implement the <a href="about/concepts/../../traits/connection.html"><code>Connection</code></a> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.StorageConnection.html">StorageConnection</a> trait allows interacting with a BonsaiDb multi-database storage instance.</p>
<p>There are three implementations of the <code>StorageConnection</code> trait:</p>
<ul>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a>: A local, file-based server implementation with no networking capabilities.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/type.Server.html"><code>Server</code></a>: A networked server implementation, written using <code>Storage</code>. This server supports <a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>- and <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>-based protocols. The QUIC protocol is preferred, but it uses UDP which many load balancers don't support. If you're exposing BonsaiDb behind a load balancer, WebSockets may be the only option depending on your host's capabilities.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html"><code>Client</code></a>: A network client implementation that connects to a <code>Server</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish/Subscribe pattern</a> enables developers to design systems that produce and receive messages. It is implemented for BonsaiDb through the <a href="about/concepts/../../traits/pubsub.html"><code>PubSub</code> and <code>Subscriber</code></a> traits.</p>
<p>A common example of what PubSub enables is implementing a simple chat system. Each chat participant can subscribe to messages on the <code>chat</code> topic, and when any participant publishes a <code>chat</code> message, all subscribers will receive a copy of that message.</p>
<p>A working example of PubSub is available at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/pubsub.rs"><code>examples/basic-local/examples/pubsub.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases-of-bonsaidb"><a class="header" href="#use-cases-of-bonsaidb">Use cases of BonsaiDb</a></h1>
<h2 id="single-database-model-no-networking"><a class="header" href="#single-database-model-no-networking">Single database model (No networking)</a></h2>
<p>This use case is most similar to utilizing SQLite for your database. In this mode, BonsaiDb directly interacts with files on your disk to provide your database. Unlike other file-based databases, however, it's easy to migrate to any of these scenarios from this starting position:</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(bonsaidb-local::Database)]
  code &lt;--&gt; local
</pre>
<p>A working example of how to use a local database can be found at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>.</p>
<h2 id="multi-database-model-no-networking"><a class="header" href="#multi-database-model-no-networking">Multi-database model (No networking)</a></h2>
<p>This model is most similar to using multiple SQLite databases. In this mode, you interact with a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> that you spawn within your code.</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(bonsaidb-local::Storage)]
  code &lt;--&gt; server
  server &lt;--&gt; local
</pre>
<p>If you look at the source behind <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html#method.open_local"><code>Database::open_local</code></a>, you'll see that the single-database model is using <code>Storage</code> under the hood.</p>
<h2 id="server-model-quic-or-websockets"><a class="header" href="#server-model-quic-or-websockets">Server model (QUIC or WebSockets)</a></h2>
<p>This model is most similar to using other document databases, like CouchDB or MongoDB. In this mode, you interact with a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html"><code>Client</code></a> that connects via either QUIC or WebSockets with a server. From the server code's perspective, this model is the same as the multi-database model, except that the server is listening for and responding to network traffic.</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server[[bonsaidb-server]]
  local[(bonsaidb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
</pre>
<p>A working example of this model can be found at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>examples/basic-server/examples/basic-server.rs</code></a>. When writing client/server applications that utilize BonsaiDb, you can have the BonsaiDb server running withing your server application. This means that your server still has the ability not use networking to interact with BonsaiDb. Regardless of if you run any other server code, your BonsaiDb server will be accessible through a <code>Client</code> over the network.</p>
<h2 id="api-platform-model-quic-or-websockets"><a class="header" href="#api-platform-model-quic-or-websockets">API Platform model (QUIC or WebSockets)</a></h2>
<p>If you're finding yourself developing an API for your application, and all of the consumers of this API are already connected to BonsaiDb, you may want to take advantage of the custom api functionality of the server:</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server[[bonsaidb-server]]
  backend[[Backend]]
  local[(bonsaidb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
  server-code &lt;--&gt; backend
  backend &lt;--&gt; server
</pre>
<p>The BonsaiDb <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.CustomServer.html"><code>CustomServer</code></a> type accepts one generic parameter that implements the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/trait.Backend.html"><code>Backend</code></a> trait. This trait is used to customize the server in many ways, but one of the associated types is a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/api/trait.Api.html"><code>Api</code></a> implementor.</p>
<p>See <a href="about/./access-models/custom-api-server.html">this page</a> for an overview of how to set up a custom api server.</p>
<h2 id="coming-later-cluster-model"><a class="header" href="#coming-later-cluster-model">Coming Later: Cluster model</a></h2>
<p>When you're at the stage of scaling beyond a single server, you will be able to upgrade your server to a cluster using the hypothetical <code>bonsaidb-cluster</code> crate. The clustering model is still being designed, but the goal is something similar to:</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server1[[server 1]]
  server2[[server 2]]
  server3[[server 3]]
  cluster[[bonsaidb-cluster]]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; cluster
  server-code &lt;--&gt; cluster
  cluster &lt;--&gt; server1
  cluster &lt;--&gt; server2
  cluster &lt;--&gt; server3
  server1 &lt;--&gt; server2
  server2 &lt;--&gt; server3
  server1 &lt;--&gt; server3
</pre>
<p>In this model, the local storage element is hidden; Each server has its own storage. This model is very similar from the viewpoint of your server and client code -- the primary difference is that the server-side connection is being established using the cluster crate. From the client's perspective, the cluster behaves as a single entity -- sending a request to any server node will result in the same result within the cluster.</p>
<p>All features of BonsaiDb will be designed to work in cluster mode seamlessly. <code>PubSub</code> will ensure that subscribers will receive messages regardless of which server they're connected to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-api-server"><a class="header" href="#custom-api-server">Custom Api Server</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/api/trait.Api.html"><code>Api</code></a> trait defines two associated types, Response, and Error. The <code>Api</code> type is akin to a &quot;request&quot; that the server receives. The server will invoke a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/api/trait.Handler.html"><code>Handler</code></a>, expecting a result with the associated Response and Error types.</p>
<blockquote>
<p>All code on this page comes from this example: <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/custom-api.rs"><code>examples/basic-server/examples/custom-api.rs</code></a>.</p>
</blockquote>
<p>This example defines two Api types with associated output types, but uses BonsaiDb's <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/api/enum.Infallible.html"><code>Infallible</code></a> type for the Error associated type:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Serialize, Deserialize, Debug)]
pub struct Ping;

impl Api for Ping {
    type Response = Pong;
    type Error = Infallible;

    fn name() -&gt; ApiName {
        ApiName::private(&quot;ping&quot;)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Pong;

#[derive(Serialize, Deserialize, Debug)]
pub struct IncrementCounter {
    amount: u64,
}

impl Api for IncrementCounter {
    type Response = Counter;
    type Error = Infallible;

    fn name() -&gt; ApiName {
        ApiName::private(&quot;increment&quot;)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Counter(pub u64);
</code></pre>
<p>To implement the server, we must define a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/api/trait.Handler.html"><code>Handler</code></a>, which is invoked each time the <code>Api</code> type is received by the server.</p>
<pre><code class="language-rust noplayground no_run">impl Backend for ExampleBackend {
    type Error = Infallible;
    type ClientData = ();
}

/// Dispatches Requests and returns Responses.
#[derive(Debug)]
pub struct ExampleHandler;

/// The Request::Ping variant has `#[actionable(protection = &quot;none&quot;)]`, which
/// causes `PingHandler` to be generated with a single method and no implicit
/// permission handling.
#[async_trait]
impl Handler&lt;ExampleBackend, Ping&gt; for ExampleHandler {
    async fn handle(
        _session: HandlerSession&lt;'_, ExampleBackend&gt;,
        _request: Ping,
    ) -&gt; HandlerResult&lt;Ping&gt; {
        Ok(Pong)
    }
}
</code></pre>
<p>Finally, the client can issue the API call and receive the response, without needing any extra steps to serialize. This works regardless of whether the client is connected via QUIC or WebSockets.</p>
<pre><code class="language-rust noplayground no_run">async fn ping_the_server(client: &amp;Client, client_name: &amp;str) -&gt; Result&lt;(), bonsaidb::core::Error&gt; {
    match client.send_api_request_async(&amp;Ping).await {
        Ok(Pong) =&gt; {
            println!(&quot;Received Pong from server on {}&quot;, client_name);
        }
        other =&gt; println!(
            &quot;Unexpected response from API call on {}: {:?}&quot;,
            client_name, other
        ),
    }

    Ok(())
}
</code></pre>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>One of the strengths of using BonsaiDb's custom api functionality is the ability to tap into the permissions handling that BonsaiDb uses. The Ping request has no permissions, but let's add permission handling to our <code>IncrementCounter</code> API. We will do this by creating an <code>increment_counter</code> function that expects two parameters: a connection to the storage layer with unrestricted permissions, and a second connection to the storage layer which has been restricted to the permissions the client invoking it is authorized to perform:</p>
<pre><code class="language-rust noplayground no_run">/// The permissible actions that can be granted for this example api.
#[derive(Debug, Action)]
#[action(actionable = bonsaidb::core::actionable)]
pub enum ExampleActions {
    Increment,
    DoSomethingCustom,
}

pub async fn increment_counter&lt;S: AsyncStorageConnection&lt;Database = C&gt;, C: AsyncKeyValue&gt;(
    storage: &amp;S,
    as_client: &amp;S,
    amount: u64,
) -&gt; Result&lt;u64, bonsaidb::core::Error&gt; {
    as_client.check_permission(&amp;[Identifier::from(&quot;increment&quot;)], &amp;ExampleActions::Increment)?;
    let database = storage.database::&lt;()&gt;(&quot;counter&quot;).await?;
    database.increment_key_by(&quot;counter&quot;, amount).await
}

#[async_trait]
impl Handler&lt;ExampleBackend, IncrementCounter&gt; for ExampleHandler {
    async fn handle(
        session: HandlerSession&lt;'_, ExampleBackend&gt;,
        request: IncrementCounter,
    ) -&gt; HandlerResult&lt;IncrementCounter&gt; {
        Ok(Counter(
            increment_counter(session.server, &amp;session.as_client, request.amount).await?,
        ))
    }
}
</code></pre>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/api/trait.Handler.html"><code>Handler</code></a> is provided a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/api/struct.HandlerSession.html"><code>HandlerSession</code></a> as well as the <code>Api</code> type, which provides all the context information needed to verify the connected client's authenticated identity and permissions. Additionally, it provides two ways to access the storage layer: with unrestricted permissions or restricted to the permissions granted to the client.</p>
<p>Let's finish configuring the server to allow all unauthenticated users the abilty to <code>Ping</code>, and all authenticated users the ability to <code>Increment</code> the counter:</p>
<pre><code class="language-rust noplayground no_run">    let server = CustomServer::&lt;ExampleBackend&gt;::open(
        ServerConfiguration::new(&quot;custom-api.bonsaidb&quot;)
            .default_permissions(Permissions::from(
                Statement::for_any()
                    .allowing(&amp;BonsaiAction::Server(ServerAction::Connect))
                    .allowing(&amp;BonsaiAction::Server(ServerAction::Authenticate(
                        AuthenticationMethod::PasswordHash,
                    ))),
            ))
            .authenticated_permissions(Permissions::from(vec![
                Statement::for_any().allowing(&amp;ExampleActions::Increment)
            ]))
            .with_api::&lt;ExampleHandler, Ping&gt;()?
            .with_api::&lt;ExampleHandler, IncrementCounter&gt;()?
            .with_schema::&lt;()&gt;()?,
    )
    .await?;
</code></pre>
<p>For more information on managing permissions, <a href="about/access-models/../../administration/permissions.html">see Administration/Permissions</a>.</p>
<p>The full example these snippets are taken from is <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/custom-api.rs">available in the repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>BonsaiDb aims to offer the majority of its functionality in <a href="integration/./local.html">local operation</a>. The <a href="integration/./server.html">networked server</a> adds some functionality on top of the local version, but its main function is to add the ability to use networking to talk to the database.</p>
<p>Because of this model, it makes it easy to transition a local database to a networked database server. Start with whatever model fits your needs today, and when your neeeds change, BonsaiDb will adapt.</p>
<h2 id="when-to-use-the-local-integration"><a class="header" href="#when-to-use-the-local-integration">When to use the <a href="integration/./local.html">Local Integration</a></a></h2>
<ul>
<li>You're going to databases from one process at a time. BonsaiDb is designed for concurrency and can scale with the capabilities of the hardware. However, the underlying storage layer that BonsaiDb is built upon, <a href="https://github.com/khonsulabs/nebari">Nebari</a>, does not support multiple processes writing its data simultaneously. If you need to access the database from multiple processes, the <a href="integration/./server.html">server integration</a> is what you should use. While it doesn't offer IPC communication today, a pull-request would be accepted to that added that functionality (along with the corresponding unit tests).</li>
<li>You have no public API/PubSub/access needs or have implemented those with another stack.</li>
</ul>
<h2 id="when-to-use-the-server-integration"><a class="header" href="#when-to-use-the-server-integration">When to use the <a href="integration/./server.html">Server Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one process or machine.</li>
<li>You are OK with downtime due to loss of service when the single server is offline. If you need to have a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> database, you should use the Cluster Integration (Coming Soon).</li>
<li>Your database load can be met with a single machine. If you have enough load that you need to share the processing power of multiple servers, you should use the Cluster Integration (Coming Soon)</li>
</ul>
<h2 id="coming-soon-when-to-use-the-cluster-integration"><a class="header" href="#coming-soon-when-to-use-the-cluster-integration">Coming Soon: When to use the <a href="integration/./cluster.html">Cluster Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one machine.</li>
<li>You need a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> setup.</li>
<li>You need/want to split load between multiple machines.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-vs-blocking"><a class="header" href="#async-vs-blocking">Async vs Blocking</a></h1>
<p>BonsaiDb supports both async and blocking (threaded) access. Its aim is to
provide a first-class experience no matter which architecture you choose for
your Rust application.</p>
<h2 id="local-only"><a class="header" href="#local-only">Local-only</a></h2>
<p><a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.Storage.html"><code>Storage</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.Database.html"><code>Database</code></a> are the blocking implementations
of BonsaiDb. These types provide the lowest overhead access to BonsaiDb as they
will block the currently executing thread to perform the operations.</p>
<p><a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.AsyncStorage.html"><code>AsyncStorage</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.AsyncDatabase.html"><code>AsyncDatabase</code></a> are simple
types that &quot;wrap&quot; <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.Storage.html"><code>Storage</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.Database.html"><code>Database</code></a> instances with
an asynchronous API. BonsaiDb does this by spawning a blocking task in Tokio.
Internally, Tokio uses a pool of threads to drive blocking operations. This may
sound like a lot of overhead, but it is surprisingly lightweight.</p>
<p>Our recommendation is to pick the programming style that fits your needs the
best. Do you need lightweight task concurrency, or is basic threading enough? If
this application grew in scope, would it ever need to be a networked
application?</p>
<p>If you anticipate needing to use BonsaiDb's networked server, you should review
the next section to consider how Tokio benefits a networked server.</p>
<h2 id="networked-server"><a class="header" href="#networked-server">Networked Server</a></h2>
<p>When building a networked server, a common strategy to handle inbound
connections is to allow each connection to have a thread. This is expensive,
however, as each thread needs its own stack allocated and is managed by the
kernel. When designing a server with long-running connections, async allows
handling more connections with fewer system resources. As such, BonsaiDb's
server is built atop Tokio, and the traits used to extend the server are
<a href="https://crates.io/crates/async_trait"><code>async_trait</code></a>s.</p>
<p>The networked server is built atop <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.AsyncStorage.html"><code>AsyncStorage</code></a>, which means
that you can convert a server instance into a blocking <a href="https://dev.bonsaidb.io/main/docs/bonsaidb_local/struct.Storage.html"><code>Storage</code></a>
instance, allowing local access to your server to remain blocking.</p>
<h2 id="networked-client"><a class="header" href="#networked-client">Networked Client</a></h2>
<p>BonsaiDb's networked client uses Tokio for all networking on non-WASM targets,
and uses the browser's WebSocket APIs for WASM targets.</p>
<p>On all non-WASM targets, the networked client can be used without a Tokio
runtime present. When instantiated this way, a runtime will automatically be run
powering the client's networking. In the future, it is possible that
non-Tokio-based networking implementations could be provided instead for the
blocking client implementation.</p>
<p>For WASM, the networked client does not provide blocking trait implementations.
If you are building for WASM, you must use the async traits.</p>
<h2 id="the-differences-between-the-apis"><a class="header" href="#the-differences-between-the-apis">The differences between the APIs</a></h2>
<p>The core traits are split into two types: blocking and async.</p>
<pre><code>| Blocking             |   Async                   |
|----------------------|---------------------------|
| `Connection`         | `AsyncConnection`         |
| `StorageConnection`  | `AsyncStorageConnection`  |
| `PubSub`             | `AsyncPubSub`             |
| `Subscriber`         | `AsyncSubscriber`         |
| `KeyValue`           | `AsyncKeyValue`           |
| `LowLevelConnection` | `AsyncLowLevelConnection` |
</code></pre>
<p>By splitting these traits, BonsaiDb tries to make it harder to accidentally use
a blocking API in an asynchronous context. In general, all other functions are
exposed in pairs: a blocking version, and an async version with the suffix
&quot;_async&quot;. For example, <code>SerializedCollection::get</code> is the blocking API, and
<code>SerializedCollection::get_async</code> is the async API.</p>
<p>When developing a project that uses both async and blocking modes of access, it
is considered a good practice to separate modules based on whether they are
blocking or not. This can help spot mistakes when the wrong type of trait is
imported in the wrong type of module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-bonsaidb-locally"><a class="header" href="#integrating-bonsaidb-locally">Integrating BonsaiDb Locally</a></h1>
<p>BonsaiDb supports multiple <a href="integration/../about/concepts/database.html">databases</a> and multiple <a href="integration/../about/concepts/schema.html">schemas</a>. However, for many applications, you only need a single database.</p>
<p>If you're only wanting a single database, the setup is straightforward: (from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let db = Database::&lt;Message&gt;::open(
    StorageConfiguration::new(&quot;basic.bonsaidb&quot;)
).await?;
</code></pre>
<p>Under the hood, BonsaiDb is creating a multi-database <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> with a local <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a> named <code>default</code> for you. If you need to switch to a multi-database model, you can open the storage and access the <code>default</code> database: (adapted from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local-multidb.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let storage = Storage::open(
    Configuration::new(&quot;basic.bonsaidb&quot;)
        .with_schema::&lt;Message&gt;()?
).await?;
let db = storage.database::&lt;Message&gt;(&quot;default&quot;).await?;
</code></pre>
<p>You can register multiple schemas so that databases can be purpose-built.</p>
<h2 id="common-traits"><a class="header" href="#common-traits">Common Traits</a></h2>
<p>To help your code transition between different modes of accessing BonsaiDb, you can use these common traits to make your methods accept any style of BonsaiDb access.</p>
<ul>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a> implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
</ul>
<p>For example, <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local-multidb.rs"><code>examples/basic-local/examples/basic-local.rs</code></a> uses this helper method to insert a record:</p>
<pre><code class="language-rust noplayground no_run">fn insert_a_message&lt;C: Connection&gt;(
    connection: &amp;C,
    value: &amp;str,
) -&gt; Result&lt;(), bonsaidb::core::Error&gt; {
    Message {
        contents: String::from(value),
        timestamp: SystemTime::now(),
    }
    .push_into(connection)?;
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-the-networked-bonsaidb-server"><a class="header" href="#integrating-the-networked-bonsaidb-server">Integrating the networked BonsaiDb Server</a></h1>
<p>To access BonsaiDb over the network, you're going to be writing two pieces of code: the server code and the client code.</p>
<h2 id="your-bonsaidb-server"><a class="header" href="#your-bonsaidb-server">Your BonsaiDb Server</a></h2>
<p>The first step is to create a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Server</code></a>, which uses local <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> under the hood. This means that if you're already using BonsaiDb in local mode, you can swap your usage of <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> with <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/type.Server.html"><code>Server</code></a> in your server code without running your database through any tools. Here's the setup code from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>basic-server/examples/basic-server.rs</code></a></p>
<pre><code class="language-rust noplayground no_run">    let server = Server::open(
        ServerConfiguration::new(&quot;server-data.bonsaidb&quot;)
            .default_permissions(DefaultPermissions::AllowAll)
            .with_schema::&lt;Shape&gt;()?,
    )
    .await?;
    if server.certificate_chain().await.is_err() {
        server.install_self_signed_certificate(true).await?;
    }
    let certificate = server
        .certificate_chain()
        .await?
        .into_end_entity_certificate();
    server.create_database::&lt;Shape&gt;(&quot;my-database&quot;, true).await?;
</code></pre>
<p>Once you have a server initialized, calling <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.CustomServer.html#method.listen_on"><code>listen_on</code></a> will begin listening for connections on the port specified. This uses the preferred native protocol which uses UDP. If you find that UDP is not working for your setup or want to put BonsaiDb behind a load balancer that doesn't support UDP, you can enable WebSocket support and call <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.CustomServer.html#method.listen_for_websockets_on"><code>listen_for_websockets_on</code></a>.</p>
<p>You can call both, but since these functions don't return until the server is shut down, you should spawn them instead:</p>
<pre><code class="language-rust noplayground no_run">let task_server = server.clone();
tokio::spawn(async move {
    task_server.listen_on(5645).await
});
let server = server.clone();
tokio::spawn(async move {
    task_server.listen_for_websockets_on(&quot;localhost:8080&quot;, false).await
});
</code></pre>
<p>If you're not running any of your own code on the server, and you're only using one listening method, you can just await the listen method of your choice in your server's main. This code example configures BonsaiDb on UDP port 5645, but this is not <a href="https://github.com/khonsulabs/bonsaidb/issues/48">an officially registered port</a>.</p>
<!-- TODO: Certificates -->
<h2 id="from-the-client"><a class="header" href="#from-the-client">From the Client</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html"><code>Client</code></a> can support both the native protocol and WebSockets. It determines which protocol to use based on the scheme in the URL:</p>
<ul>
<li><code>bonsaidb://host:port</code> will connect using the native BonsaiDb protocol.</li>
<li><code>ws://host:port</code> will connect using WebSockets.</li>
</ul>
<p>Here's how to connect, from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>examples/basic-server/examples/basic-server.rs</code></a>:</p>
<pre><code class="language-rust noplayground no_run">Client::new(
    Url::parse(&quot;bonsaidb://localhost:5645&quot;)?,
    Some(certificate),
)
.await?
</code></pre>
<p>This is using a pinned certificate to connect. Other methods are supported, but better certificate management is coming soon.</p>
<!-- TODO: Certificates -->
<h2 id="common-traits-1"><a class="header" href="#common-traits-1">Common Traits</a></h2>
<ul>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/type.Server.html"><code>Server</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.CustomServer.html#method.database"><code>Server::database()</code></a> returns a local <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>. Local access in the server executable doesn't go over the network.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html"><code>Client</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html#method.database"><code>Client::database()</code></a> returns a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-into-a-bonsaidb-cluster"><a class="header" href="#integrating-into-a-bonsaidb-cluster">Integrating into a BonsaiDb Cluster</a></h1>
<p>Coming Soon.</p>
<p>The goals of this feature are to make clustering simple. We hope to provide an experience that allows someone who is operating a networked server to desire two types of clusters:</p>
<h2 id="one-leader-mode"><a class="header" href="#one-leader-mode">One-leader mode</a></h2>
<p>When setting up a cluster initially, you will begin with one-leader mode. In this mode, you can add as many nodes to the cluster as you wish, but only one node will be processing all of the data updates. All nodes can handle requests, but requests that can't be served locally will be forwarded to the leader. This allows for the use of read-replicas to alleviate load in some read-heavy situations.</p>
<p>Another benefit of this mode are that it supports a two-node configuration. If you're scaling your app and need a reliable backup for quicker disaster recovery, you can operate a read replica and manually failover when the situation arises.</p>
<p>If you decide to allow automatic failover in this mode, there is a chance for data loss, as the leader does not wait for read-replicas to synchronize data. Any transactions that committed and were not synchronized before the outage occurred would not be on the other servers. Thus, this mode is <em>not intended for high-availability configurations</em>, although some users may elect to use it in such a configuration knowing these limitations.</p>
<h2 id="quorum-mode"><a class="header" href="#quorum-mode">Quorum mode</a></h2>
<p>Once you have a cluster with at least 3 nodes, you can switch the cluster into quorum mode. For any given <code>N</code> nodes, all requests must reach an agreed response by <code>N / 2 + 1</code> members. For example, in a cluster of 3 nodes, there must be 2 successful responses before a client can receive a response to its request.</p>
<p>In quorum mode, your data is divided into shards and those shards replicated throughout the cluster onto at least 3 nodes (configurable). Initially, with just 3 nodes available, the only benefits are having a highly-available cluster with no data loss during when a single node goes down.</p>
<p>As you add more nodes to your cluster, however, you can re-balance your databases to move shards. The author of BonsaiDb did not enjoy this process in CouchDB when he had to do it and aims to make these tools easy and effortless to use. Ideally, there would be a low-maintenance mode that would allow the cluster to re-shard itself authomatically during allowed maintenance periods, ensuring data is distributed more evenly amongst the cluster.</p>
<p>Additional long-term dreams of quorum mode include the ability to customize node selection criteria on a per-database basis. The practical use of node selection is to ensure that at least 3 unique nodes are picked for each shard. However, allowing custom logic to evaluate which nodes should be selected for any database would allow ultimate flexibility. For example, if you have a globally deployed application, and you have some data that is geographically specific, you could locate each region's database on nodes within those locations' data centers.</p>
<h2 id="when"><a class="header" href="#when">When?</a></h2>
<p>Clustering is an important part of the design of <a href="https://github.com/khonsulabs/cosmicverge">Cosmic Verge</a>. As such, it is a priority for us to work on. But, the overall game is a very large project, so we hesitate to make any promises on timelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.Connection.html"><code>Connection</code> trait</a> contains functions for interacting with collections in a database. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.Connection.html">messy documentation</a> due to the lifetimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageconnection"><a class="header" href="#storageconnection">StorageConnection</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.StorageConnection.html"><code>StorageConnection</code> trait</a> contains functions for interacting with BonsaiDb's multi-database storage. This trait is implemented by these types:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Storage.html"><code>Storage</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.CustomServer.html"><code>CustomServer&lt;Backend&gt;</code></a> / <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/type.Server.html"><code>Server</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html"><code>Client</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.StorageConnection.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub-trait"><a class="header" href="#pubsub-trait">PubSub Trait</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/pubsub/trait.PubSub.html"><code>PubSub</code> trait</a> contains functions for using <a href="traits/../about/concepts/pubsub.html">PubSub</a> in BonsaiDb. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/pubsub/trait.PubSub.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-value-trait"><a class="header" href="#key-value-trait">Key-Value Trait</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/keyvalue/trait.KeyValue.html"><code>KeyValue</code> trait</a> contains functions for interacting the atomic key-value store. The key-value store provides high-performance atomic operations without ACID compliance. Once the data is persisted to disk, it holds the same guarantees as all of BonsaiDb, but this feature is designed for high throughput and does not wait to persist to disk before reporting success to the client. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/keyvalue/trait.KeyValue.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-trait"><a class="header" href="#key-trait">Key Trait</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html">Key</a> trait enables types to define a serialization and deserialization
format that preserves the order of the original type in serialized form. Whe
comparing two values encoded with <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.KeyEncoding.html#tymethod.as_ord_bytes"><code>as_ord_bytes()</code></a> using a
byte-by-byte comparison operation should match the result produced by comparing
the two original values using the <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>. For integer formats, this
generally means encoding the bytes in network byte order (big endian).</p>
<p>For example, let's consider two values:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th><code>as_ord_bytes()</code></th></tr></thead><tbody>
<tr><td><code>1u16</code></td><td><code>[ 0, 1]</code></td></tr>
<tr><td><code>300u16</code></td><td><code>[ 1, 44]</code></td></tr>
</tbody></table>
</div>
<p><code>1_u16.cmp(&amp;300_u16)</code> and <code>1_u16.as_ord_bytes()?.cmp(&amp;300_u16.as_ord_bytes()?)</code>
both produce Ordering::Less.</p>
<h2 id="implementing-the-key-trait"><a class="header" href="#implementing-the-key-trait">Implementing the <code>Key</code> trait</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html"><code>Key</code></a> trait declares two functions: <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.KeyEncoding.html#tymethod.as_ord_bytes"><code>as_ord_bytes()</code></a> and
<a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/key/trait.Key.html#tymethod.from_ord_bytes"><code>from_ord_bytes</code></a>. The intention is to convert the type to bytes
using a network byte order for numerical types, and for non-numerical types, the
bytes need to be stored in binary-sortable order.</p>
<p>Here is how BonsaiDb implements Key for <code>EnumKey</code>:</p>
<pre><code class="language-rust noplayground no_run">impl&lt;'a, T&gt; Key&lt;'a&gt; for EnumKey&lt;T&gt;
where
    T: ToPrimitive + FromPrimitive + Clone + Eq + Ord + std::fmt::Debug + Send + Sync,
{
    fn from_ord_bytes(bytes: &amp;'a [u8]) -&gt; Result&lt;Self, Self::Error&gt; {
        let primitive = u64::decode_variable(bytes)?;
        T::from_u64(primitive)
            .map(Self)
            .ok_or_else(|| std::io::Error::new(ErrorKind::InvalidData, UnknownEnumVariant))
    }
}

impl&lt;'a, T&gt; KeyEncoding&lt;'a, Self&gt; for EnumKey&lt;T&gt;
where
    T: ToPrimitive + FromPrimitive + Clone + Eq + Ord + std::fmt::Debug + Send + Sync,
{
    type Error = std::io::Error;
    const LENGTH: Option&lt;usize&gt; = None;

    fn as_ord_bytes(&amp;'a self) -&gt; Result&lt;Cow&lt;'a, [u8]&gt;, Self::Error&gt; {
        let integer = self
            .0
            .to_u64()
            .map(Unsigned::from)
            .ok_or_else(|| std::io::Error::new(ErrorKind::InvalidData, IncorrectByteLength))?;
        Ok(Cow::Owned(integer.to_variable_vec()?))
    }
}
</code></pre>
<p>By implementing <code>Key</code> you can take full control of converting your view keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-an-enum-as-a-key"><a class="header" href="#using-an-enum-as-a-key">Using an Enum as a Key</a></h2>
<p>The easiest way to expose an enum is to derive <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.FromPrimitive.html"><code>num_traits::FromPrimitive</code></a> and <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.ToPrimitive.html"><code>num_traits::ToPrimitive</code></a> using <a href="https://crates.io/crates/num-derive">num-derive</a>, and add an <code>impl EnumKey</code> line:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Serialize, Deserialize, Eq, PartialEq, Debug, Key, Clone)]
pub enum Category {
    Rust,
    Cooking,
}
</code></pre>
<p>The View code remains unchanged, although the associated Key type can now be set to <code>Option&lt;Category&gt;</code>. The queries can now use the enum instead of a <code>String</code>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(&amp;Some(Category::Rust))
        .reduce()?;
</code></pre>
<p>BonsaiDb will convert the enum to a u64 and use that value as the Key. A u64 was chosen to ensure fairly wide compatibility even with some extreme usages of bitmasks. If you wish to customize this behavior, you can implement <code>Key</code> directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>BonsaiDb attempts to have reasonable default configuration options, but it's important to browse the available options to ensure there aren't options that might help your particular needs.</p>
<h2 id="storage-configuration"><a class="header" href="#storage-configuration">Storage Configuration</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.StorageConfiguration.html"><code>StorageConfiguration</code></a> structure is used to open a local-only database. The <code>ServerConfiguration</code> struct contains <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.storage">an instance of <code>StorageConfiguration</code></a>, and all configuration optionsl are available on it.</p>
<h3 id="vault-key-storage"><a class="header" href="#vault-key-storage">Vault Key Storage</a></h3>
<p>By default, BonsaiDb sets <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.vault_key_storage"><code>vault_key_storage</code></a> to a file stored within the database folder. This is <strong>incredibly insecure and should not be used outside of testing</strong>.</p>
<p>For secure encryption, it is important to store the vault keys in a location that is separate from the database. If the keys are on the same harware as the database, anyone with access to the disk will be able to decrypt the stored data.</p>
<p>If you have more than one server, you can still use <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/vault/struct.LocalVaultKeyStorage.html"><code>LocalVaultKeyStorage</code></a> in conjunction with a mounted network share for reasonable security practices -- assuming the network share itself is properly secured.</p>
<p>If you have an S3-compatible storage service available, you can use <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/keystorage/s3/index.html"><code>bonsaidb::keystorage::s3</code></a> to store the vault keys with that service.</p>
<p>Note that by storing your keys remotely, your BonsaiDb database will not be able to be opened unless the keys are able to be read.</p>
<p>Vault Key Storage can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.vault_key_storage"><code>Builder::vault_key_storage</code></a>.</p>
<h3 id="default-encryption-key"><a class="header" href="#default-encryption-key">Default Encryption Key</a></h3>
<p>By setting <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.default_encryption_key"><code>default_encryption_key</code></a> to a key, all data will be encrypted when written to the disk.</p>
<p>If <code>default_encryption_key</code> is <code>None</code>, encryption will still be performed for collections that return a key from <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.Collection.html#method.encryption_key"><code>Collection::encryption_key()</code></a>.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.default_encryption_key"><code>Builder::default_encryption_key</code></a>.</p>
<h3 id="tasks-worker-count"><a class="header" href="#tasks-worker-count">Tasks: Worker Count</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.Tasks.html#structfield.worker_count"><code>tasks.worker_count</code></a> setting controls the number of worker tasks that are spawned to process background tasks.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.tasks_worker_count"><code>Builder::tasks_worker_count</code></a>.</p>
<h3 id="views-check-integrity-on-open"><a class="header" href="#views-check-integrity-on-open">Views: Check Integrity on Open</a></h3>
<p>When <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.Views.html#structfield.check_integrity_on_open"><code>views.check_integrity_on_open</code></a> is true, all views in all databases will be checked on startup for integrity. If this value is false, the integrity of the view will not be checked until it is accessed for the first time.</p>
<p>By default, BonsaiDb delays checking a view's integrity until its accessed for the first time. it may, however, be preferred to have a higher startup time to ensure consistent response times once the server is running after a restart of the server.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.check_view_integrity_on_open"><code>Builder::check_view_integrity_on_open</code></a>.</p>
<h3 id="key-value-persistence"><a class="header" href="#key-value-persistence">Key-Value Persistence</a></h3>
<p>The Key-Value store is designed to be a lightweight, atomic data store that is suitable for caching data, tracking metrics, or other situations where a Collection might be overkill.</p>
<p>By default, BonsaiDb persists Key-Value store changes to disk immediately. For light usage, this will not be noticable, and it ensures that no data will ever be lost.</p>
<p>If you're willing to accept potentially losing recent writes, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.key_value_persistence"><code>key_value_persistence</code></a> can be configured to lazily commit changes to disk. The documentation for <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.KeyValuePersistence.html"><code>KeyValuePersistence</code></a> contains examples as well as an explanation of how the rules are evaluated.</p>
<p>Key-Value Persistence can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/trait.Builder.html#tymethod.key_value_persistence"><code>Builder::key_value_persistence</code></a>.</p>
<h2 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html"><code>ServerConfiguration</code></a> structure is used to open a BonsaiDb server. Being built atop the local storage engine, this structure exposes <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.storage">an instance of <code>StorageConfiguration</code></a>, allowing full customization.</p>
<h3 id="server-name"><a class="header" href="#server-name">Server Name</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.server_name"><code>server_name</code></a> setting is for the primary DNS name of the server. The server's TLS certificate should be valid for the server's name.</p>
<p>When using ACME, this setting controls the primary certificate requested.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#method.server_name">a builder-style method</a>.</p>
<h3 id="client-simultaneous-request-limit"><a class="header" href="#client-simultaneous-request-limit">Client Simultaneous Request Limit</a></h3>
<p>BonsaiDb's networking protocols support multiple requests to be sent before any responses have been received, sometimes called pipelining. Without a limit, a single malicious client could send a large number of load-inducing requests and cause reliability of service issues for other clients.</p>
<p>By limiting each connection's maximum ability to a reasonable number, it allows clients to take advantage of pipelining without allowing any one client to saturate the server with requests.</p>
<p>This limit is set using the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.client_simultaneous_request_limit">client_simultaneous_request_limit</a> field or <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#method.client_simultaneous_request_limit">builder-style method</a>.</p>
<h3 id="request-worker-count"><a class="header" href="#request-worker-count">Request Worker Count</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.request_workers"><code>request_workers</code></a> configuration controls the number of worker tasks that process incoming requests from connected clients. It can also be set via a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#method.request_workers">builder-style method</a>.</p>
<h3 id="default-permissions-and-authenticated-permissions"><a class="header" href="#default-permissions-and-authenticated-permissions">Default Permissions and Authenticated Permissions</a></h3>
<p>When first connecting to a server, the client is unauthenticated and is granted the permissions defined by <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.default_permissions"><code>default_permissions</code></a>. Once a connected client has authenticated, the client will be granted <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#structfield.authenticated_permissions"><code>authenticated_permissions</code></a> in addition to whatever permissions already granted by the authenticated role.</p>
<p>By default, both <code>default_permissions</code> and <code>authenticated_permissions</code> contain no granted permissions. This means that by default, no connections are allowed to a server, as the connection hasn't been gramted <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.BonsaiAction.html#variant.Server"><code>BonsaiAction::Server(</code></a><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.ServerAction.html#variant.Connect"><code>ServerAction::Connect() )</code></a>.</p>
<h3 id="acme-configuration-letsencrypt"><a class="header" href="#acme-configuration-letsencrypt">ACME Configuration (LetsEncrypt)</a></h3>
<p>ACME has two configurable options, a contact email and the ACME directory.</p>
<h4 id="acme-contact-email"><a class="header" href="#acme-contact-email">ACME Contact Email</a></h4>
<p>The contact email is submitted to the ACME directory as part of requesting a TLS certificate. It is optional for the LetsEncrypt directories.</p>
<p>A valid value for this field begins with <code>mailto:</code>.</p>
<p>The contact email can be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.AcmeConfiguration.html#structfield.contact_email"><code>acme.contact_email</code></a> or the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#method.acme_contact_email">builder-style method</a>.</p>
<h4 id="acme-directory"><a class="header" href="#acme-directory">ACME Directory</a></h4>
<p>By default, BonsaiDb uses the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/constant.LETS_ENCRYPT_PRODUCTION_DIRECTORY.html">production LetsEncrypt directory</a>, but any ACME directory can be specified.</p>
<p>The directory can be set using <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.AcmeConfiguration.html#structfield.directory"><code>acme.directory</code></a> or the <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/server/struct.ServerConfiguration.html#method.acme_directory">builder-style method</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions-1"><a class="header" href="#permissions-1">Permissions</a></h1>
<p>BonsaiDb uses <a href="https://en.wikipedia.org/wiki/Role-based_access_control">role-based access control (RBAC)</a>. In short, permissions are granted through statements within permission groups. Users are able to <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/client/struct.Client.html#method.login_with_password_str">log in</a> and receive permissions that were granted via permission groups or roles.</p>
<p>This section has two subsections:</p>
<ul>
<li><a href="administration/./permission-statements.html">Permission Statements</a>: An overview of the resource names and actions used within BonsaiDb.</li>
<li><a href="administration/./rbac.html">Users, Groups, and Roles</a>: A more thorough explanation of BonsaiDb's access control.</li>
</ul>
<p>While the most common use case will be granting permissions to act upon BonsaiDb itself, the permissions system is designed to be generic enough that it can be used as the application's permission system if desired.</p>
<p>By default, no actions are allowed.</p>
<p>Currently, permissions are only applied to connections over a network. In <a href="https://github.com/khonsulabs/bonsaidb/issues/68">the future</a>, permissions will be able to be applied even on local connections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permission-statements"><a class="header" href="#permission-statements">Permission Statements</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/struct.Statement.html">Statement</a> grants permissions to execute <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/trait.Action.html"><code>Action</code>s</a> on <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/struct.ResourceName.html"><code>ResourceName</code>s</a>.</p>
<h2 id="actions-and-resources"><a class="header" href="#actions-and-resources">Actions and Resources</a></h2>
<p><code>ResourceName</code>s are simply namespaced <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/enum.Identifier.html"><code>Identifier</code>s</a>. An example could be: <code>&quot;bonsaidb&quot;.*.&quot;khonsulabs-admin.users&quot;.1</code>. Each segment can be <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/enum.Identifier.html#variant.String">a string</a>, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/enum.Identifier.html#variant.Integer">an integer</a>, or <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/enum.Identifier.html#variant.Any">a wildcard (<code>*</code>)</a>.</p>
<p>In BonsaiDb, nearly everything has a resource name. The example above refers to a document with ID <code>1</code> in the <code>khonsulabs-admin.users</code> collection in any database. The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/index.html"><code>bonsaidb::core::permissions::bonsai</code></a> module contains functions to create properly formatted <code>ResourceName</code>s.</p>
<p>Also within the same module are the built-in <code>Action</code>s. The base enum for all actions used within BonsaiDb is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.BonsaiAction.html"><code>BonsaiAction</code></a> Below is an overview of the resource names and actions by category.</p>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.ServerAction.html"><code>ServerAction</code></a> enum contains the actions that are related to <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/connection/trait.StorageConnection.html"><code>StorageConnection</code></a>. For APIs that accept a database name parameter, the resource name will be <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>database_resource_name(database)</code></a>. For all other actions, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.bonsaidb_resource_name.html"><code>bonsaidb_resource_name()</code></a>.</p>
<p>For actions that operate upon users (e.g., creating a user), the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.user_resource_name.html">user_resource_name(username)</a>.</p>
<h4 id="at-rest-encryption"><a class="header" href="#at-rest-encryption">At-rest Encryption</a></h4>
<p>Access to encrypted information can be controlled by limiting access to the encryption key used. Currently, BonsaiDb only has support for a shared master key, but in the future additional keys will be able to be created. Because <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.EncryptionKeyAction.html#variant.Encrypt"><code>Encrypt</code></a> and <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.EncryptionKeyAction.html#variant.Decrypt"><code>Decrypt</code></a> are separate actions, access to read and write can be controlled independently.</p>
<p>The resource name for an encryption key is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.encryption_key_resource_name.html"><code>encryption_key_resource_name(key_id)</code></a>.</p>
<h3 id="database-1"><a class="header" href="#database-1">Database</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/enum.DatabaseAction.html"><code>DatabaseAction</code></a> enum contains the actions that are related to a specific database. Actions that act on the database directly will use the resource name <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>database_resource_name(database)</code></a>.</p>
<p>For <code>Collection</code>s, there are three resource names used. For actions that operate on the collection directly, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>collection_resource_name(database, collection)</code></a>. For actions that operate on a document, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.document_resource_name.html"><code>document_resource_name(database, collection, id)</code></a>. Finally, for actions that operate on a <code>View</code>, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.view_resource_name.html"><code>view_resource_name(database, view)</code></a>.</p>
<p>For actions that operate upon the key-value entry, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.keyvalue_key_resource_name.html"><code>keyvalue_key_resource_name(database, namespace, key)</code></a>.</p>
<p>For actions that operate on a <code>PubSub</code> topic, the resource name is <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/permissions/bonsai/fn.pubsub_topic_resource_name.html"><code>pubsub_topic_resource_name(database, topic)</code></a>.</p>
<h2 id="statement-examples"><a class="header" href="#statement-examples">Statement Examples</a></h2>
<p><em>Coming Soon</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-groups-and-roles"><a class="header" href="#users-groups-and-roles">Users, Groups, and Roles</a></h1>
<p>The most common flow that a database administrator needs to support is granting a user the ability to take specific actions on specific resources. To accomplish this, a <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/admin/struct.PermissionGroup.html"><code>PermissionGroup</code></a> must be created containing the permission statements, covered in <a href="administration/./permission-statements.html">the previous section</a>, that you wish to apply.</p>
<p><code>PermissionGroup</code>s can be assigned directly to users by adding the group ID to their <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/admin/struct.User.html"><code>User</code> document</a>.</p>
<p>At first glance, <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/admin/struct.Role.html"><code>Role</code>s</a> may appear somewhat redundant. One or more <code>PermissionGroup</code>s can be assigned to a role, and roles can be assigned to a user. Why would you want to use roles at all?</p>
<p>The general advice the authors of BonsaiDb suggest is to use groups for limited amounts of functionality, keeping each group's list of statements concise and easy to understand. Then, create roles that combine groups of functionality in meaningful ways. One meaningful way could be creating roles based on job titles inside of a company. In theory, a person's job defines what they do within the company.</p>
<p>In practice, permissions are never as clean as one would hope, which is why BonsaiDb allows assigning groups and roles to users directly. Roles should be used as much as possible, but sometimes assigning a group directly is just needed. For example, imagine the CEO telling you, &quot;I know Bob is just a sales guy, but he needs to be able to update this record. I trust him more than the other sales people. Just make it happen.&quot; As the database administrator, you can decide whether to introduce a new role or just temporarily assign an extra group to this one user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="at-rest-encryption-1"><a class="header" href="#at-rest-encryption-1">At-Rest Encryption</a></h1>
<p>BonsaiDb offers at-rest encryption. An overview of how it works is available <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/vault/index.html">in the <code>bonsaidb::local::vault</code> module</a>.</p>
<h2 id="enabling-at-rest-encryption-by-default"><a class="header" href="#enabling-at-rest-encryption-by-default">Enabling at-rest encryption by default</a></h2>
<p>When opening your BonsaiDb instance, there is a configuration option <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.default_encryption_key"><code>default_encryption_key</code></a>. Once this is set, all new data written that supports being encrypted will be encrypted at-rest.</p>
<pre><code class="language-rust noplayground no_run">let storage = Storage::open(
    StorageConfiguration::new(&amp;directory)
        .vault_key_storage(vault_key_storage)
        .default_encryption_key(KeyId::Master)
)
.await?;
</code></pre>
<h2 id="enabling-at-rest-encryption-on-a-per-collection-basis"><a class="header" href="#enabling-at-rest-encryption-on-a-per-collection-basis">Enabling at-rest encryption on a per-collection basis</a></h2>
<p><a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/schema/trait.Collection.html#method.encryption_key"><code>Collection::encryption_key()</code></a> can be overridden on a per-Collection basis. If a collection requests encryption but the feature is disabled, an error will be generated.</p>
<p>To enable a collection to be encrypted when the feature is enabled, only return a key when <a href="https://dev.bonsaidb.io/main/docs/bonsaidb/core/constant.ENCRYPTION_ENABLED.html">ENCRYPTION_ENABLED</a> is true.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
