<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Large file storage support for BonsaiDb."><meta name="keywords" content="rust, rustlang, rust-lang, files"><title>bonsaidb::files - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bonsaidb/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bonsaidb/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate files</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#derives">Derive Macros</a></li></ul></div></section><div id="sidebar-vars" data-name="files" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bonsaidb/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a href="../index.html">bonsaidb</a>::<wbr><a class="mod" href="#">files</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/bonsaidb_files/lib.rs.html#1-544">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Large file storage support for BonsaiDb.</p>
<p>This crate provides support for storing large files in
<a href="https://bonsaidb.io/">BonsaiDb</a>. While BonsaiDb’s document size limit is 4
gigabytes, the requirement that each document is loaded in memory fully can
cause higher memory usage when storing larger files.</p>
<h2 id="fileconfig"><a href="#fileconfig"><code>FileConfig</code></a></h2>
<p>The <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> trait allows customizing the <a href="../core/schema/struct.CollectionName.html" title="CollectionName"><code>CollectionName</code></a>s and
block size. If you want to use smaller or larger blocks, you can. If you
want to store more than one set of files in the same database, you can use
two <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> implementors with different <a href="../core/schema/struct.CollectionName.html" title="CollectionName"><code>CollectionName</code></a>s.</p>
<p>For most users, the provided implementation <a href="struct.BonsaiFiles.html" title="BonsaiFiles"><code>BonsaiFiles</code></a> will work for
them.</p>
<h2 id="basic-example"><a href="#basic-example">Basic Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">io</span>::{<span class="ident">Read</span>, <span class="ident">Seek</span>, <span class="ident">SeekFrom</span>, <span class="ident">Write</span>},
    <span class="ident">mem::size_of</span>,
};

<span class="kw">use</span> <span class="ident">bonsaidb_files</span>::{<span class="ident">BonsaiFiles</span>, <span class="ident">FileConfig</span>, <span class="ident">FilesSchema</span>};
<span class="kw">use</span> <span class="ident">bonsaidb_local</span>::{
    <span class="ident">config</span>::{<span class="ident">Builder</span>, <span class="ident">StorageConfiguration</span>},
    <span class="ident">Database</span>,
};

<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">test</span>, <span class="ident">test</span>)]</span>
<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Create a database for our files. If you would like to use these</span>
    <span class="comment">// collections in an existing datasbase/schema, `BonsaiFiles` exposes a</span>
    <span class="comment">// function `define_collections()` which can be called from your</span>
    <span class="comment">// `Schema::define_collections()` implementation.</span>
    <span class="comment">//</span>
    <span class="comment">// Or, if you&#39;re using the Schema derive macro, you can add a parameter</span>
    <span class="comment">// `include = [FilesSchema&lt;BonsaiFiles&gt;]` to use BonsaiFiles within your</span>
    <span class="comment">// existing schema.</span>
    <span class="kw">let</span> <span class="ident">database</span> <span class="op">=</span> <span class="ident">Database::open</span>::<span class="op">&lt;</span><span class="ident">FilesSchema</span><span class="op">&lt;</span><span class="ident">BonsaiFiles</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">StorageConfiguration::new</span>(
        <span class="string">&quot;basic-files.bonsaidb&quot;</span>,
    ))<span class="question-mark">?</span>;

    <span class="comment">// This crate provides a very basic path-based file storage. Documents can</span>
    <span class="comment">// be up to 4GB in size, but must be loaded completely to access. Files</span>
    <span class="comment">// stored using `bonsaidb-files` are broken into blocks and can be streamed</span>
    <span class="comment">// and/or randomly accessed.</span>
    <span class="comment">//</span>
    <span class="comment">// The `BonsaiFiles` type implements `FileConfig` and defines a block size</span>
    <span class="comment">// of 64kb.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one_megabyte</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>);
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">one_megabyte</span>.<span class="ident">capacity</span>() <span class="op">/</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
        <span class="comment">// Each u32 in the file will be the current offset in the file.</span>
        <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">u32::try_from</span>(<span class="ident">i</span> <span class="op">*</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>()).<span class="ident">unwrap</span>();
        <span class="ident">one_megabyte</span>.<span class="ident">extend</span>(<span class="ident">offset</span>.<span class="ident">to_be_bytes</span>());
    }
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">BonsaiFiles::build</span>(<span class="string">&quot;some-file&quot;</span>)
        .<span class="ident">contents</span>(<span class="kw-2">&amp;</span><span class="ident">one_megabyte</span>)
        .<span class="ident">create</span>(<span class="kw-2">&amp;</span><span class="ident">database</span>)<span class="question-mark">?</span>;

    <span class="comment">// By default, files will be stored at the root level:</span>
    <span class="macro">assert_eq!</span>(<span class="ident">file</span>.<span class="ident">path</span>(), <span class="string">&quot;/some-file&quot;</span>);

    <span class="comment">// We can access this file&#39;s contents using `std::io::Read` and</span>
    <span class="comment">// `std::io::Seek`.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">contents</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">contents</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">contents</span>.<span class="ident">len</span>(), <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>());
    <span class="ident">contents</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom::Start</span>(<span class="number">1024</span>))<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">offset</span> <span class="op">=</span> [<span class="number">0</span>; <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>()];
    <span class="ident">contents</span>.<span class="ident">read_exact</span>(<span class="kw-2">&amp;mut</span> <span class="ident">offset</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">u32::from_be_bytes</span>(<span class="ident">offset</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">offset</span>, <span class="number">1024</span>);
    <span class="ident">drop</span>(<span class="ident">contents</span>);

    <span class="comment">// Files can be appended to, but existing contents cannot be modified.</span>
    <span class="comment">// `File::append()` can be used to write data that you have in memory.</span>
    <span class="comment">// Alternatively, a buffered writer can be used to write larger amounts of</span>
    <span class="comment">// data using `std::io::Write`.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">writer</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">append_buffered</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">reader</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">one_megabyte</span>[..];
    <span class="kw">let</span> <span class="ident">bytes_written</span> <span class="op">=</span> <span class="ident">std::io::copy</span>(<span class="kw-2">&amp;mut</span> <span class="ident">reader</span>, <span class="kw-2">&amp;mut</span> <span class="ident">writer</span>)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">bytes_written</span>, <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>());
    <span class="ident">writer</span>.<span class="ident">flush</span>()<span class="question-mark">?</span>;
    <span class="comment">// The writer will attempt to flush on drop if there are any bytes remaining</span>
    <span class="comment">// in the buffer. Any errors will be ignored, however, so it is safer to</span>
    <span class="comment">// flush where you can handle the error.</span>
    <span class="ident">drop</span>(<span class="ident">writer</span>);

    <span class="comment">// Verify the file has the new contents.</span>
    <span class="kw">let</span> <span class="ident">contents</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">contents</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(
        <span class="ident">contents</span>.<span class="ident">len</span>(),
        <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>() <span class="op">*</span> <span class="number">2</span>
    );

    <span class="comment">// Clean up the file.</span>
    <span class="ident">file</span>.<span class="ident">delete</span>()<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="async-support"><a href="#async-support">Async Support</a></h2>
<p>This crate adds implementations of <code>tokio::io::AsyncRead</code> and
<code>tokio::io::AsyncWrite</code> when the <code>async</code> feature flag is enabled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">io::SeekFrom</span>, <span class="ident">mem::size_of</span>};

<span class="kw">use</span> <span class="ident">bonsaidb_files</span>::{<span class="ident">BonsaiFiles</span>, <span class="ident">FileConfig</span>, <span class="ident">FilesSchema</span>};
<span class="kw">use</span> <span class="ident">bonsaidb_local</span>::{
    <span class="ident">config</span>::{<span class="ident">Builder</span>, <span class="ident">StorageConfiguration</span>},
    <span class="ident">AsyncDatabase</span>,
};
<span class="kw">use</span> <span class="ident">tokio::io</span>::{<span class="ident">AsyncReadExt</span>, <span class="ident">AsyncSeekExt</span>, <span class="ident">AsyncWriteExt</span>};

<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">test</span>), <span class="ident">tokio::main</span>)]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">test</span>, <span class="ident">tokio::test</span>)]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Create a database for our files. If you would like to use these</span>
    <span class="comment">// collections in an existing datasbase/schema, `BonsaiFiles` exposes a</span>
    <span class="comment">// function `define_collections()` which can be called from your</span>
    <span class="comment">// `Schema::define_collections()` implementation.</span>
    <span class="comment">//</span>
    <span class="comment">// Or, if you&#39;re using the Schema derive macro, you can add a parameter</span>
    <span class="comment">// `include = [FilesSchema&lt;BonsaiFiles&gt;]` to use BonsaiFiles within your</span>
    <span class="comment">// existing schema.</span>
    <span class="kw">let</span> <span class="ident">database</span> <span class="op">=</span> <span class="ident">AsyncDatabase::open</span>::<span class="op">&lt;</span><span class="ident">FilesSchema</span><span class="op">&lt;</span><span class="ident">BonsaiFiles</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">StorageConfiguration::new</span>(
        <span class="string">&quot;basic-files.bonsaidb&quot;</span>,
    ))
    .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// This crate provides a very basic path-based file storage. Documents can</span>
    <span class="comment">// be up to 4GB in size, but must be loaded completely to access. Files</span>
    <span class="comment">// stored using `bonsaidb-files` are broken into blocks and can be streamed</span>
    <span class="comment">// and/or randomly accessed.</span>
    <span class="comment">//</span>
    <span class="comment">// The `BonsaiFiles` type implements `FileConfig` and defines a block size</span>
    <span class="comment">// of 64kb.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one_megabyte</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>);
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">one_megabyte</span>.<span class="ident">capacity</span>() <span class="op">/</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
        <span class="comment">// Each u32 in the file will be the current offset in the file.</span>
        <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">u32::try_from</span>(<span class="ident">i</span> <span class="op">*</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>()).<span class="ident">unwrap</span>();
        <span class="ident">one_megabyte</span>.<span class="ident">extend</span>(<span class="ident">offset</span>.<span class="ident">to_be_bytes</span>());
    }
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">BonsaiFiles::build</span>(<span class="string">&quot;async-file&quot;</span>)
        .<span class="ident">contents</span>(<span class="kw-2">&amp;</span><span class="ident">one_megabyte</span>)
        .<span class="ident">create_async</span>(<span class="kw-2">&amp;</span><span class="ident">database</span>)
        .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// By default, files will be stored at the root level:</span>
    <span class="macro">assert_eq!</span>(<span class="ident">file</span>.<span class="ident">path</span>(), <span class="string">&quot;/async-file&quot;</span>);

    <span class="comment">// We can access this file&#39;s contents using `tokio::io::AsyncRead` and</span>
    <span class="comment">// `tokio::io::AsyncSeek`. Due to how the buffer contents reader works, it</span>
    <span class="comment">// is safe to call this type&#39;s `std::io::Seek` implementation in an async</span>
    <span class="comment">// context, as it is non-blocking.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">contents</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">contents</span>().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">contents</span>.<span class="ident">len</span>(), <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>());
    <span class="ident">contents</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom::Start</span>(<span class="number">1024</span>)).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">offset</span> <span class="op">=</span> [<span class="number">0</span>; <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>()];
    <span class="ident">contents</span>.<span class="ident">read_exact</span>(<span class="kw-2">&amp;mut</span> <span class="ident">offset</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">u32::from_be_bytes</span>(<span class="ident">offset</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">offset</span>, <span class="number">1024</span>);
    <span class="ident">drop</span>(<span class="ident">contents</span>);

    <span class="comment">// Files can be appended to, but existing contents cannot be modified.</span>
    <span class="comment">// `File::append()` can be used to write data that you have in memory.</span>
    <span class="comment">// Alternatively, a buffered writer can be used to write larger amounts of</span>
    <span class="comment">// data using `tokio::io::AsyncWrite`.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">writer</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">append_buffered</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">reader</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">one_megabyte</span>[..];
    <span class="kw">let</span> <span class="ident">bytes_written</span> <span class="op">=</span> <span class="ident">tokio::io::copy</span>(<span class="kw-2">&amp;mut</span> <span class="ident">reader</span>, <span class="kw-2">&amp;mut</span> <span class="ident">writer</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">bytes_written</span>, <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>());
    <span class="ident">writer</span>.<span class="ident">flush</span>().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="comment">// The writer will attempt to flush on drop if there are any bytes remaining</span>
    <span class="comment">// in the buffer. Any errors will be ignored, however, so it is safer to</span>
    <span class="comment">// flush where you can handle the error.</span>
    <span class="ident">drop</span>(<span class="ident">writer</span>);

    <span class="comment">// Verify the file has the new contents.</span>
    <span class="kw">let</span> <span class="ident">contents</span> <span class="op">=</span> <span class="ident">file</span>.<span class="ident">contents</span>().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(
        <span class="ident">contents</span>.<span class="ident">len</span>(),
        <span class="ident">u64::try_from</span>(<span class="ident">one_megabyte</span>.<span class="ident">len</span>()).<span class="ident">unwrap</span>() <span class="op">*</span> <span class="number">2</span>
    );

    <span class="comment">// Clean up the file.</span>
    <span class="ident">file</span>.<span class="ident">delete</span>().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="direct/index.html" title="bonsaidb::files::direct mod">direct</a></div><div class="item-right docblock-short"><p>Types for accessing files directly from a connection to a database. These
types perform no permission checking beyond what BonsaiDb normally checks as
part of accessing/updating the underlying collections.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BonsaiFiles.html" title="bonsaidb::files::BonsaiFiles struct">BonsaiFiles</a></div><div class="item-right docblock-short"><p>A default configuration for storing files within BonsaiDb.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.FilesSchema.html" title="bonsaidb::files::FilesSchema struct">FilesSchema</a></div><div class="item-right docblock-short"><p>A schema implementation that allows using any <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> as a <a href="../core/schema/trait.Schema.html" title="Schema"><code>Schema</code></a>
without manually implementing <a href="../core/schema/trait.Schema.html" title="Schema"><code>Schema</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Statistics.html" title="bonsaidb::files::Statistics struct">Statistics</a></div><div class="item-right docblock-short"><p>Statistics about a set of files contained in a collection.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="bonsaidb::files::Error enum">Error</a></div><div class="item-right docblock-short"><p>Errors that can be returned when interacting with files.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Truncate.html" title="bonsaidb::files::Truncate enum">Truncate</a></div><div class="item-right docblock-short"><p>Controls which location of a file to remove data from during a truncation.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FileConfig.html" title="bonsaidb::files::FileConfig trait">FileConfig</a></div><div class="item-right docblock-short"><p>A configuration for a set of <a href="direct/struct.File.html">stored files</a>.</p>
</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.FileConfig.html" title="bonsaidb::files::FileConfig derive">FileConfig</a></div><div class="item-right docblock-short"><p>Derives the <code>bonsaidb::files::FileConfig</code> trait.
<code>#[api(metadata = MetadataType, block_size = 65_536, authority = &quot;authority&quot;, files_name = &quot;files&quot;, blocks_name = &quot;blocks&quot;, core = bonsaidb::core, files = bosaidb::files)]</code>
all arguments are optional</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bonsaidb" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>