<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Large file storage support for BonsaiDb."><meta name="keywords" content="rust, rustlang, rust-lang, files"><title>bonsaidb::files - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../crates.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bonsaidb/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../bonsaidb/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate files</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a href="../index.html">bonsaidb</a>::<wbr><a class="mod" href="#">files</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/bonsaidb_files/lib.rs.html#1-547">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Large file storage support for BonsaiDb.</p>
<p>This crate provides support for storing large files in
<a href="https://bonsaidb.io/">BonsaiDb</a>. While BonsaiDb’s document size limit is 4
gigabytes, the requirement that each document is loaded in memory fully can
cause higher memory usage when storing larger files.</p>
<h2 id="fileconfig"><a href="#fileconfig"><code>FileConfig</code></a></h2>
<p>The <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> trait allows customizing the <a href="../core/schema/struct.CollectionName.html" title="CollectionName"><code>CollectionName</code></a>s and
block size. If you want to use smaller or larger blocks, you can. If you
want to store more than one set of files in the same database, you can use
two <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> implementors with different <a href="../core/schema/struct.CollectionName.html" title="CollectionName"><code>CollectionName</code></a>s.</p>
<p>For most users, the provided implementation <a href="struct.BonsaiFiles.html" title="BonsaiFiles"><code>BonsaiFiles</code></a> will work for
them.</p>
<h2 id="basic-example"><a href="#basic-example">Basic Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{Read, Seek, SeekFrom, Write};
<span class="kw">use </span>std::mem::size_of;

<span class="kw">use </span>bonsaidb_files::{BonsaiFiles, FileConfig, FilesSchema};
<span class="kw">use </span>bonsaidb_local::config::{Builder, StorageConfiguration};
<span class="kw">use </span>bonsaidb_local::Database;

<span class="attribute">#[cfg_attr(test, test)]
</span><span class="kw">fn </span>main() -&gt; anyhow::Result&lt;()&gt; {
    <span class="comment">// Create a database for our files. If you would like to use these
    // collections in an existing datasbase/schema, `BonsaiFiles` exposes a
    // function `define_collections()` which can be called from your
    // `Schema::define_collections()` implementation.
    //
    // Or, if you&#39;re using the Schema derive macro, you can add a parameter
    // `include = [FilesSchema&lt;BonsaiFiles&gt;]` to use BonsaiFiles within your
    // existing schema.
    </span><span class="kw">let </span>database = Database::open::&lt;FilesSchema&lt;BonsaiFiles&gt;&gt;(StorageConfiguration::new(
        <span class="string">&quot;basic-files.bonsaidb&quot;</span>,
    ))<span class="question-mark">?</span>;

    <span class="comment">// This crate provides a very basic path-based file storage. Documents can
    // be up to 4GB in size, but must be loaded completely to access. Files
    // stored using `bonsaidb-files` are broken into blocks and can be streamed
    // and/or randomly accessed.
    //
    // The `BonsaiFiles` type implements `FileConfig` and defines a block size
    // of 64kb.
    </span><span class="kw">let </span><span class="kw-2">mut </span>one_megabyte = Vec::with_capacity(<span class="number">1024 </span>* <span class="number">1024</span>);
    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..one_megabyte.capacity() / size_of::&lt;u32&gt;() {
        <span class="comment">// Each u32 in the file will be the current offset in the file.
        </span><span class="kw">let </span>offset = u32::try_from(i * size_of::&lt;u32&gt;()).unwrap();
        one_megabyte.extend(offset.to_be_bytes());
    }
    <span class="kw">let </span><span class="kw-2">mut </span>file = BonsaiFiles::build(<span class="string">&quot;some-file&quot;</span>)
        .contents(<span class="kw-2">&amp;</span>one_megabyte)
        .create(<span class="kw-2">&amp;</span>database)<span class="question-mark">?</span>;

    <span class="comment">// By default, files will be stored at the root level:
    </span><span class="macro">assert_eq!</span>(file.path(), <span class="string">&quot;/some-file&quot;</span>);

    <span class="comment">// We can access this file&#39;s contents using `std::io::Read` and
    // `std::io::Seek`.
    </span><span class="kw">let </span><span class="kw-2">mut </span>contents = file.contents()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(contents.len(), u64::try_from(one_megabyte.len()).unwrap());
    contents.seek(SeekFrom::Start(<span class="number">1024</span>))<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>offset = [<span class="number">0</span>; size_of::&lt;u32&gt;()];
    contents.read_exact(<span class="kw-2">&amp;mut </span>offset)<span class="question-mark">?</span>;
    <span class="kw">let </span>offset = u32::from_be_bytes(offset);
    <span class="macro">assert_eq!</span>(offset, <span class="number">1024</span>);
    drop(contents);

    <span class="comment">// Files can be appended to, but existing contents cannot be modified.
    // `File::append()` can be used to write data that you have in memory.
    // Alternatively, a buffered writer can be used to write larger amounts of
    // data using `std::io::Write`.
    </span><span class="kw">let </span><span class="kw-2">mut </span>writer = file.append_buffered();
    <span class="kw">let </span><span class="kw-2">mut </span>reader = <span class="kw-2">&amp;</span>one_megabyte[..];
    <span class="kw">let </span>bytes_written = std::io::copy(<span class="kw-2">&amp;mut </span>reader, <span class="kw-2">&amp;mut </span>writer)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(bytes_written, u64::try_from(one_megabyte.len()).unwrap());
    writer.flush()<span class="question-mark">?</span>;
    <span class="comment">// The writer will attempt to flush on drop if there are any bytes remaining
    // in the buffer. Any errors will be ignored, however, so it is safer to
    // flush where you can handle the error.
    </span>drop(writer);

    <span class="comment">// Verify the file has the new contents.
    </span><span class="kw">let </span>contents = file.contents()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(
        contents.len(),
        u64::try_from(one_megabyte.len()).unwrap() * <span class="number">2
    </span>);

    <span class="comment">// Clean up the file.
    </span>file.delete()<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="async-support"><a href="#async-support">Async Support</a></h2>
<p>This crate adds implementations of <code>tokio::io::AsyncRead</code> and
<code>tokio::io::AsyncWrite</code> when the <code>async</code> feature flag is enabled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::SeekFrom;
<span class="kw">use </span>std::mem::size_of;

<span class="kw">use </span>bonsaidb_files::{BonsaiFiles, FileConfig, FilesSchema};
<span class="kw">use </span>bonsaidb_local::config::{Builder, StorageConfiguration};
<span class="kw">use </span>bonsaidb_local::AsyncDatabase;
<span class="kw">use </span>tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt};

<span class="attribute">#[cfg_attr(not(test), tokio::main)]
#[cfg_attr(test, tokio::test)]
</span><span class="kw">async fn </span>main() -&gt; anyhow::Result&lt;()&gt; {
    <span class="comment">// Create a database for our files. If you would like to use these
    // collections in an existing datasbase/schema, `BonsaiFiles` exposes a
    // function `define_collections()` which can be called from your
    // `Schema::define_collections()` implementation.
    //
    // Or, if you&#39;re using the Schema derive macro, you can add a parameter
    // `include = [FilesSchema&lt;BonsaiFiles&gt;]` to use BonsaiFiles within your
    // existing schema.
    </span><span class="kw">let </span>database = AsyncDatabase::open::&lt;FilesSchema&lt;BonsaiFiles&gt;&gt;(StorageConfiguration::new(
        <span class="string">&quot;basic-files.bonsaidb&quot;</span>,
    ))
    .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// This crate provides a very basic path-based file storage. Documents can
    // be up to 4GB in size, but must be loaded completely to access. Files
    // stored using `bonsaidb-files` are broken into blocks and can be streamed
    // and/or randomly accessed.
    //
    // The `BonsaiFiles` type implements `FileConfig` and defines a block size
    // of 64kb.
    </span><span class="kw">let </span><span class="kw-2">mut </span>one_megabyte = Vec::with_capacity(<span class="number">1024 </span>* <span class="number">1024</span>);
    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..one_megabyte.capacity() / size_of::&lt;u32&gt;() {
        <span class="comment">// Each u32 in the file will be the current offset in the file.
        </span><span class="kw">let </span>offset = u32::try_from(i * size_of::&lt;u32&gt;()).unwrap();
        one_megabyte.extend(offset.to_be_bytes());
    }
    <span class="kw">let </span><span class="kw-2">mut </span>file = BonsaiFiles::build(<span class="string">&quot;async-file&quot;</span>)
        .contents(<span class="kw-2">&amp;</span>one_megabyte)
        .create_async(<span class="kw-2">&amp;</span>database)
        .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// By default, files will be stored at the root level:
    </span><span class="macro">assert_eq!</span>(file.path(), <span class="string">&quot;/async-file&quot;</span>);

    <span class="comment">// We can access this file&#39;s contents using `tokio::io::AsyncRead` and
    // `tokio::io::AsyncSeek`. Due to how the buffer contents reader works, it
    // is safe to call this type&#39;s `std::io::Seek` implementation in an async
    // context, as it is non-blocking.
    </span><span class="kw">let </span><span class="kw-2">mut </span>contents = file.contents().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(contents.len(), u64::try_from(one_megabyte.len()).unwrap());
    contents.seek(SeekFrom::Start(<span class="number">1024</span>)).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>offset = [<span class="number">0</span>; size_of::&lt;u32&gt;()];
    contents.read_exact(<span class="kw-2">&amp;mut </span>offset).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span>offset = u32::from_be_bytes(offset);
    <span class="macro">assert_eq!</span>(offset, <span class="number">1024</span>);
    drop(contents);

    <span class="comment">// Files can be appended to, but existing contents cannot be modified.
    // `File::append()` can be used to write data that you have in memory.
    // Alternatively, a buffered writer can be used to write larger amounts of
    // data using `tokio::io::AsyncWrite`.
    </span><span class="kw">let </span><span class="kw-2">mut </span>writer = file.append_buffered();
    <span class="kw">let </span><span class="kw-2">mut </span>reader = <span class="kw-2">&amp;</span>one_megabyte[..];
    <span class="kw">let </span>bytes_written = tokio::io::copy(<span class="kw-2">&amp;mut </span>reader, <span class="kw-2">&amp;mut </span>writer).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(bytes_written, u64::try_from(one_megabyte.len()).unwrap());
    writer.flush().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="comment">// The writer will attempt to flush on drop if there are any bytes remaining
    // in the buffer. Any errors will be ignored, however, so it is safer to
    // flush where you can handle the error.
    </span>drop(writer);

    <span class="comment">// Verify the file has the new contents.
    </span><span class="kw">let </span>contents = file.contents().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(
        contents.len(),
        u64::try_from(one_megabyte.len()).unwrap() * <span class="number">2
    </span>);

    <span class="comment">// Clean up the file.
    </span>file.delete().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="direct/index.html" title="bonsaidb::files::direct mod">direct</a></div><div class="item-right docblock-short">Types for accessing files directly from a connection to a database. These
types perform no permission checking beyond what BonsaiDb normally checks as
part of accessing/updating the underlying collections.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BonsaiFiles.html" title="bonsaidb::files::BonsaiFiles struct">BonsaiFiles</a></div><div class="item-right docblock-short">A default configuration for storing files within BonsaiDb.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.FilesSchema.html" title="bonsaidb::files::FilesSchema struct">FilesSchema</a></div><div class="item-right docblock-short">A schema implementation that allows using any <a href="trait.FileConfig.html" title="FileConfig"><code>FileConfig</code></a> as a <a href="../core/schema/trait.Schema.html" title="Schema"><code>Schema</code></a>
without manually implementing <a href="../core/schema/trait.Schema.html" title="Schema"><code>Schema</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Statistics.html" title="bonsaidb::files::Statistics struct">Statistics</a></div><div class="item-right docblock-short">Statistics about a set of files contained in a collection.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="bonsaidb::files::Error enum">Error</a></div><div class="item-right docblock-short">Errors that can be returned when interacting with files.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Truncate.html" title="bonsaidb::files::Truncate enum">Truncate</a></div><div class="item-right docblock-short">Controls which location of a file to remove data from during a truncation.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FileConfig.html" title="bonsaidb::files::FileConfig trait">FileConfig</a></div><div class="item-right docblock-short">A configuration for a set of <a href="direct/struct.File.html">stored files</a>.</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.FileConfig.html" title="bonsaidb::files::FileConfig derive">FileConfig</a></div><div class="item-right docblock-short">Derives the <code>bonsaidb::files::FileConfig</code> trait.
<code>#[api(metadata = MetadataType, block_size = 65_536, authority = &quot;authority&quot;, files_name = &quot;files&quot;, blocks_name = &quot;blocks&quot;, core = bonsaidb::core, files = bosaidb::files)]</code>
all arguments are optional</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bonsaidb" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>